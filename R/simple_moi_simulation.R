#' Simple simulation of MOI SNV data
#' 
#' @description Generate read count data in support of SNVs partioned by 
#' mixtures of clones within a host. This is done by setting true
#' clonal mixture proportions and the underlying sampling probabilities
#' for each clone. Then a random sample of underlying SNV probabilities
#' is sampled from either a rbeta or rtexp distrubition with given parameters
#' and read counts are generated by bionimial conditonal on the underlying
#' SNV probability with the clone sampling probabilities. 
#' 
#' @param n.samples number of infected hosts in population
#' @param n.snps number of SNPs observed
#' @param moi number of clonal infections
#' @param coverage vector of total coverage per sample
#' @param error probability of error in read counts
#' @param pi.true optional matrix of true mixture proportions
#' @param mu.true optional matrix of true mixture components
#' @param aaf optional vector of underlying SNV proportions 
#' @param aaf.dist  sampling distribution for SNV frequencies
#' @param ... other parameters to pass to aaf.dist
#' @return A list containing the following elements
#'  pi.true an n.samples by moi matrix containing true clonal proportions
#'  mu.true an n.samplps by moi matrix containing true genotype proportions
#'  aaf an n.snps vector of under SNV probabilities
#'  read.counts an n.samples by n.snps matrix containing read counts supporting each SNV
#'  error.counts an n.samples by n.snps matrix containing number of error reads 
#' @importFrom MCMCpack rdirichlet
#' @export

simulate_moi <- function(n.samples, n.snps, moi, coverage, error,
                         pi.true = NULL, mu.true = NULL, aaf = NULL,
                         aaf.dist, ...) {
    # I/0 checking
    if (moi < 2 || moi > 5) {
        stop("Number of infections must be between 2 and 5, inclusive")
    }
    
    
    if (length(coverage) != n.samples) {
        stop("coverage vector must have same length as n.samples")
    }
    
    if(error > 1 || error < 0) {
        stop("Error probability must be between 0 and 1")
    }
    
    # check clonal mixture matrix
    if(!is.null(pi.true)) {
        if(!inherits(pi.true, "matrix")) {
            stop("pi.true must be a matrix.")
        }
        
        if(!all(dim(pi.true) == c(moi, n.samples))) {
            stop("pi.true must have dimensions moi by n.samples")
        }
        
        check.sums <- colSums(pi.true)
        if(!all.equal(sum(check.sums), n.samples)) {
            stop("Columns of pi.true must sum to 1.")
        }
        
    }
    
    # check genotype proportion matrix
    if(!is.null(mu.true)) {
        if(!inherits(mu.true, "matrix")) {
            stop("mu.true must be a matrix")
        }
        
        if(!all(dim(mu.true) == c(moi, n.samples))) {
            stop("mu.true must have dimensions moi by n.samples")
        }
        
        if(any(mu.true < 0) || any(mu.true > 1)) {
            stop("All entries of mu.true must be between 0 and 1.")
        }
    }
    
    if(!is.null(aaf)) {
        if(length(aaf) != n.snps) {
            stop("aaf must have length n.snps")
        }
    }
    
    # step 1, generate underlying parameters
    if (is.null(pi.true)) {
        pi.true <- t(MCMCpack::rdirichlet(n.samples, 
                                          alpha = rep(1, moi)))
        
    }
    
    if (is.null(mu.true)) {
        # produces an moi by n.samples
        mu.true <- replicate(n.samples, runif(moi))
    }
    # generate mixture indexes for each SNV for each isolate
    # produce an n.samples by n.snps matrix with assignments
    clusters <- foreach(i=1:n.samples, .combine = cbind) %dopar% {
        sample(1:moi, n.snps, replace = TRUE, prob = pi.true[,i])
    } 
    # generate underlying SNV frequenciences
    if (is.null(aaf)) {
        aaf.dist <- match.fun(aaf.dist)
        aaf <- aaf.dist(n=n.snps, ...)
    }
    # conditional probabilities of observing each SNV given underlying
    # clonal genotype
    # generate matrix of assignments
    sample.p <- foreach(i =1:n.samples, .combine = cbind) %dopar% {
        mu.true[clusters[,i],i]
    }
    
    # generate whether SNV is observed using Bernoulli distribution
    snv.observed <- foreach(i = 1:n.samples, .combine = cbind) %dopar% {
        rbinom(n.snps, size = 1, prob = aaf)
    }
    # multiply by the frequency of each alternate allele 
    sample.p <- snv.observed * sample.p
    # generate observed read counts in support of each SNV for each clone
    read.counts <- foreach(i = 1:n.samples, .combine = cbind) %dopar% {
        rbinom(n.snps, size = coverage[i], prob = sample.p[,i])
    }
    
    
    if (error > 0) {
        # generate Binomial realisations for probability
        # of observing error reads in support of SNV 
        error.counts <- foreach(i = 1:n.samples, .combine = cbind) %dopar% {
            rbinom(n.snps, size = coverage[i], prob = error)
        }
        
        
        read.counts <- read.counts - error.counts
        read.counts[read.counts < 0] <- 0
        
    }    
    
    
    return(list(pi.true = pi.true, 
                mu.true = mu.true,
                moi = clusters,
                aaf = aaf,
                read.counts = read.counts))
    
}