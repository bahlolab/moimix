# Title: moi_simulation.R
# Authors: Katherine Smith, Melanie Bahlo, Stuart Lee
# Description: Function to simulate impact of multiplicity
# of infection in R. Simulation to assess impact of non MOI=1


#' Simulate multiplicity of infection in parasite sequencing data
#'
#' @details This function simulates SNV data for fixed MOI. 
#' It requires passing a function as an argument that specifies the 
#' alternate allele frequency distribution.
#' The sampling distributions available are either the truncated exponential
#' or beta. The parameters for these distributions are passed as additional
#' arguments to the function. For rtexp a mutation rate (theta) and truncation
#' parameter t are required, while for rbeta shape parameters are required.
#'
#' @param n.samples integer number of humans sampled for Plasmodium infection
#' @param n.snps integer number of SNPs examined
#' @param moi integer number of infections per human
#' @param coverage integer number of reads covering each base for each isolate
#' @param error numeric probability of error in base call
#' @param clone.props optional n.samples by moi matrix of fixed clonal proportions (default NUL)
#' @param maf.dist minor allele frequency distribution sampling function
#' (DEFAULT=rtexp)
#' @param ... parameters to be passed to maf.dist See details.
#' @return A list with the following elements
#'  clone.props: a matrix of dimension n.samples by moi
#'  allele.freq: A vector of length n.snps containing observed allele frequency
#'  distribution generated by maf.dist
#'  obs.error.prop: the total observed error proportion
#'  obs.alt.counts: A matrix of size n.samples by n.snps containing the
#'  observed number of reads in support of each SNP.
#' @import foreach
#' @importFrom MCMCpack rdirichlet
#' @export
simulateMOI <- function(n.samples,
                        n.snps,
                        moi,
                        coverage,
                        error,
                        clone.props = NULL, 
                        maf.dist = rtexp, ...) {
    #---I/O checking
    
    # error probablity must be a probability
    stopifnot(error >= 0 && error <= 1)
    
    # moi must be between 1 and 5
    stopifnot(moi >= 1 && moi <= 5)
    
    # coverage must be either same length as n.samples
    stopifnot(length(coverage) == n.samples | length(coverage) == 1)
    
    if (length(coverage) == 1) {
        coverage <- rep(coverage, n.samples)
    }
    
    # check CLONE PROPS has same length as samples
    if (!(is.null(clone.props))) {
        # check clone.props is a matrix 
        if(!(inherits(clone.props, "matrix"))) {
            stop("clone.props must be a matrix")
        }
        
        # check dimensions match
        if(!(all(dim(clone.props) == c(n.samples, moi)))) {
            stop(paste("clone.props matrix must have dimensions ", 
                       paste(c(n.samples, moi), collapse = ",")))
        }
        # check matrix rows sum to 1
        check.sum <- apply(clone.props, 1, sum)
        if(!all(check.sum == 1)) {
            stop("All rows of clone.props must sum to 1.")
        }
        
    }
    
    maf.dist <- match.fun(maf.dist)
    
    #--- I. SIMULATE MULTIPLICITY OF INFECTION DATA    
    # Given the MOI, simulate the true proportions of each clone
    # from a Dirichlet dbn
    if(is.null(clone.props)) {
        
        # Simulate the proportion of each clone according to the Dirichlet distribution
        # this is a a matrix of dimensions n.samples by moi
        clone.props <- MCMCpack::rdirichlet(n.samples, rep(1, moi))
        print(clone.props)
        # check that the sum of clone proportions is one for each person
        stopifnot(all.equal(apply(clone.props, 1, sum), rep(1, n.samples)))
    }
    # Simulate the number of reads from each clone from a multinomial dbn
    # this is a list of N matrices of dimension K x S
    reads.per.clone <- foreach(i=1:n.samples) %dopar% {
        rmultinom(n = n.snps, size = coverage[i], prob = clone.props[i,])
    }
    print(reads.per.clone)    
    # Simulate minor (alternate) allele frequencies from a either
    # truncated exponential distribution with range [0,1] or a beta distribution
    # this is a vector of length S
    aaf <- maf.dist(n = n.snps, ...)
    geno.props <- foreach(i=1:n.samples, .combine=rbind) %dopar% {
        runif(moi)
    }
    # 5. Simulate alleles for each clone at each SNP according to a Bernouilli
    # distribution using AAFs from (4)  want a K x S matrix of alleles for each
    # sample, i.e. the haplotypes of each clone store in a list of length N
    alleles <- foreach(i=1:n.samples) %dopar% {
        t(sapply(geno.props[i,], rbinom, n = n.snps,size = 1))
    }
    # Generate the true proportions of genotypes from a clone
    # - calculate the counts reads supporting alt allele in SNV
    # a list of length N with all the alt allele counts
    alt.alleles.count <- foreach(i=1:n.samples) %dopar% {
        reads.per.clone[[i]] * alleles[[i]]
    }
    #     # - compute the proportion of reads supporting each clone genome-wide
    #     geno.props <- lapply(1:n.samples,
    #                          function(i) rowSums(alt.alleles.count[[i]]) /
    #                              (moi *n.snps * coverage[i]))
    
    
    # Given the alleles and the reads per clone, what is the number of alt alleles
    # observed in the absence of sequencing error?
    # Sum over columns and transpose to obtain an N x S matrix
    # containing the count of alt alleles for each sample and SNP
    alt.counts <- t(sapply(1:n.samples,
                           function(i) colSums(alt.alleles.count[[i]])))
    
    

    if(error > 0) {
        # 6. Simulate the number of sequencing errors per clone, sample and SNP
        # according to a Binomial distribution.
        # This is a list of N matrices of dimension K x S
        error.counts <- foreach(i=1:n.samples) %dopar% {
            matrix(sapply(reads.per.clone[[i]],
                          rbinom,
                          n= 1,
                          prob = error),
                   ncol = n.snps,
                   byrow = TRUE)
        }
        # Calculate the observed error proportion
        obs.error.prop <- sum(sapply(error.counts,
                                     sum)) / (n.samples * n.snps * sum(coverage))
        
        # Calculate an N x S matrix indicating how sequencing errors will
        # affect the alt allele counts
        y <- lapply(alleles, function(x) { ifelse(x==1, -1, 1) })
        
        error.alt.change <- t(sapply(1:n.samples,
                                     function(i) colSums(error.counts[[i]]*y[[i]])))
        
        # 7. Compute the observed number of alternate alleles for each sample and SNP
        obs.alt.counts <- alt.counts + error.alt.change
        
        #8. if errors have reduced counts below 0 or greater than coverage
        # then cap results at 0
        obs.alt.counts[obs.alt.counts < 0] <- 0
        # if errors have put counts above their coverage fix that
        obs.alt.counts <- foreach(i=1:nrow(obs.alt.counts), .combine=rbind) %dopar% {
            ifelse(obs.alt.counts[i,] > coverage[i], 
                   coverage[i], 
                   obs.alt.counts[i,])
        }
        rownames(obs.alt.counts) <- NULL
    }
    else {
        obs.alt.counts <- alt.counts
        obs.error.prop <- 0
    }
    
    
    
    list(clone.props = clone.props,
         geno.props = geno.props,
         allele.freq = aaf,
         obs.error.prop = obs.error.prop,
         obs.alt.counts = obs.alt.counts)
    
}

### II. APPLY MOI STRATEGIES TO SIMULATED DATA

#' Apply handling strategies to simulated data
#'
#' @details This function generates several datasets pertaining
#' to different mulitplicity of infection strategies. Strategy A
#' simply removes all samples with MOI > 1. Strategy B calls the
#' major allele for each sample and single nucleotide variant.
#'
#' @param simMOI.list The list output from simulateMOI
#' @return A list containing three entries:
#'  true.alleles: A matrix containing the true alleles from simulation
#'  monoclonal.alleles: A matrix with MOI=1 samples
#'  sample.major.allels: A matrix containing major alleles for each
#'  sample and SNV
#'
#' @export
handleMOI <- function(simMOI.list) {

  stop("This function no longer works.")

  alleles <- simMOI.list[["alleles"]]
  coverage <- simMOI.list[["param"]]["coverage"]
  n.samples <- simMOI.list[["param"]]["n.samples"]
  n.snps <- simMOI.list[["param"]]["n.snps"]
  obs.alt.counts <- simMOI.list[["obs.alt.counts"]]

  # convert the list of true alleles to a matrix
  true.alleles <- do.call("rbind", alleles)

  ## Strategy A. Remove all samples with MOI>1
  # this assumes that MOI is perfectly detectable, which isn't realistic
  moi.one <- which(simMOI.list[["moi.observed"]] == 1)
  monoclonal.alleles <- do.call("rbind", alleles[moi.one])

  ## Strategy B. Choose the major allele for each sample and SNV
  # This is the allele supported by the highest number of reads
  # what to do if have same number of ref and alt alleles?
  # Always choose one allele, or assign randomly?
  # N x S matrix of logical values
  high.support <- obs.alt.counts < (coverage / 2)
  # convert to N x S numeric matrix
  sample.major.alleles <- matrix(as.numeric(high.support),
                                 nrow = n.samples,
                                 ncol = n.snps)

  list(true.alleles = true.alleles,
       monoclonal.alleles = monoclonal.alleles,
       sample.major.alleles = sample.major.alleles)

}




