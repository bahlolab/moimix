# Title: moi_simulation.R
# Authors: Katherine Smith, Melanie Bahlo, Stuart Lee
# Description: Function to simulate impact of multiplicity
# of infection in R. Simulation to assess impact of non MOI=1


#' Simulate multiplicity of infection in parasite sequencing data
#'
#' @details This function simulates MOI data and applies two simple MOI
#' handling strategies. It assumes that MOI in a population is fixed.
#' It requires passing a function as
#' an argument that specifies the minor allele frequency distribution.
#' The sampling distributions available are either truncated exponential
#' or beta. The parameters for these distributions are passed as additional
#' arguments to the function. For rtexp a mutation rate and truncation
#' parameter are required, while for rbeta shape parameters are required.
#'
#' @param n.samples integer number of humans sampled for Plasmodium
#' @param n.snps integer number of SNPs examined
#' @param moi integer number of infections per human
#' @param coverage integer number of reads covering each base for each isolate
#' @param error numeric probability of error in base call
#' @param dirichlet.param integer vector of length 2, specifying mixing
#' parameters for dirichilet distribution
#' @param maf.dist minor allele frequency distribution sampling function
#' (DEFAULT=rtexp)
#' @param ... parameters to be passed to maf.dist See details.
#' @return A list with the following elements
#'  clone.props: a list of n.sample vectors of length K containing the proprotion
#'  of each clone for each sample
#'  allele.freq: A vector of length n.snps containing observed allele frequency
#'  distribution generated by maf.dist
#'  obs.error.prop: the total observed error proportion
#'  obs.alt.counts: A matrix of size n.samples by n.snps containing the
#'  observed number of reads in support of each SNP.
#' @export
simulateMOI <- function(n.samples,
                        n.snps,
                        moi,
                        coverage,
                        error,
                        dirichlet.param,
                        maf.dist = rtexp, ...) {

  # - dirichlet parameter vector must be of length 2
  stopifnot(length(dirichlet.param) == 2)
  # error probablity must be a probability
  stopifnot(error >= 0 && error <= 1)

  # moi must be between 1 and 5
  stopifnot(moi >= 1 && moi <= 5)

  # coverage must be either same length as n.samples
  # or length 1
  stopifnot(length(coverage) == n.samples | length(coverage) == 1)

  maf.dist <- match.fun(maf.dist)
  ### I. SIMULATE MULTIPLICITY OF INFECTION DATA
  # Create vector moi of length N
  moi.sample <- rep(moi, n.samples)

  # 2. Given the MOI, simulate the true proportions of each clone
  #from a Dirichlet dbn

  # 2a. Obtain the parameters of the Dirichlet dbn for each person
  # this is a list of N vectors of length K
  dirichlet.alphas <- lapply(moi.sample, dirichletAlpha,
                             m = dirichlet.param[1],
                             a0 = dirichlet.param[2])

  # 2b. Simulate the proportion of each clone according to the Dirichlet distribution
  # this is a list of N vectors of length K
  clone.props <- lapply(dirichlet.alphas, rdirichlet)

  # check that the sum of clone proportions is one for each person
  stopifnot(all.equal(sapply(clone.props, sum), rep(1, n.samples)))

  # 3. Simulate the number of reads from each clone from a multinomial dbn
  # this is a list of N matrices of dimension K x S
  reads.per.clone <- lapply(1:n.samples,
                            function(i) rmultinom(n = n.snps,
                                                  size = coverage[i],
                                                  prob = clone.props[[i]]))


  # 4. Simulate minor (alternate) allele frequencies from a either
  # truncated exponential distribution with range [0,1] or a beta distribution
  # this is a vector of length S
  aaf <- maf.dist(n = n.snps, ...)

  # 5. Simulate alleles for each clone at each SNP according to a Bernouilli
  # distribution using AAFs from (4)  want a K x S matrix of alleles for each
  # sample, i.e. the haplotypes of each clone store in a list of length N
  alleles <- lapply(1:n.samples,
                    FUN = function(i) sapply(aaf, rbinom,
                                             n = moi,
                                             size = 1))
  # Generate the true proportions of genotypes from a clone
  # - calculate the counts reads supporting alt allele in SNV
  alt.alleles.count <- lapply(1:n.samples,
                              function(i) reads.per.clone[[i]] * alleles[[i]])
  # - compute the proportion of reads supporting each clone genome-wide
  geno.props <- lapply(1:n.samples,
               function(i) rowSums(alt.alleles.count[[i]]) /
                 (moi *n.snps * coverage[i]))


  # Given the alleles and the reads per clone, what is the number of alt alleles
  # observed in the absence of sequencing error?
  # Sum over columns and transpose to obtain an N x S matrix
  # containing the count of alt alleles for each sample and SNP
  alt.counts <- t(sapply(1:n.samples,
                         function(i) colSums(alt.alleles.count[[i]])))


  # 6. Simulate the number of sequencing errors per clone, sample and SNP
  # according to a Binomial distribution.
  # This is a list of N matrices of dimension K x S
  error.counts <- lapply(1:n.samples,
                         function(i) matrix(sapply(reads.per.clone[[i]],
                                                         rbinom,
                                                         n= 1,
                                                         prob = error),
                                                  ncol = n.snps,
                                            byrow = TRUE))
  # Calculate the observed error proportion
  obs.error.prop <- sum(sapply(error.counts,
                               sum)) / (n.samples * n.snps * coverage)

  # Calculate an N x S matrix indicating how sequencing errors will
  # affect the alt allele counts
  y <- lapply(alleles, function(x) { ifelse(x==1, -1, 1) })

  error.alt.change <- t(sapply(1:n.samples,
                               function(i) colSums(error.counts[[i]]*y[[i]])))

  # 7. Compute the observed number of alternate alleles for each sample and SNP
  obs.alt.counts <- alt.counts + error.alt.change

  #8. if errors have reduced counts below 0 or greater than coverage then fix that
  obs.alt.counts[obs.alt.counts < 0] <- 0

  # at the moment assuming uniform coverage here
  obs.alt.counts[obs.alt.counts > max(coverage)] <- max(coverage)

  list(clone.props = clone.props,
       geno.props = geno.props,
       allele.freq = aaf,
       obs.error.prop = obs.error.prop,
       obs.alt.counts = obs.alt.counts)

}

### II. APPLY MOI STRATEGIES TO SIMULATED DATA

#' Apply handling strategies to simulated data
#'
#' @details This function generates several datasets pertaining
#' to different mulitplicity of infection strategies. Strategy A
#' simply removes all samples with MOI > 1. Strategy B calls the
#' major allele for each sample and single nucleotide variant.
#'
#' @param simMOI.list The list output from simulateMOI
#' @return A list containing three entries:
#'  true.alleles: A matrix containing the true alleles from simulation
#'  monoclonal.alleles: A matrix with MOI=1 samples
#'  sample.major.allels: A matrix containing major alleles for each
#'  sample and SNV
#'
#' @export
handleMOI <- function(simMOI.list) {

  stop("This function no longer works.")

  alleles <- simMOI.list[["alleles"]]
  coverage <- simMOI.list[["param"]]["coverage"]
  n.samples <- simMOI.list[["param"]]["n.samples"]
  n.snps <- simMOI.list[["param"]]["n.snps"]
  obs.alt.counts <- simMOI.list[["obs.alt.counts"]]

  # convert the list of true alleles to a matrix
  true.alleles <- do.call("rbind", alleles)

  ## Strategy A. Remove all samples with MOI>1
  # this assumes that MOI is perfectly detectable, which isn't realistic
  moi.one <- which(simMOI.list[["moi.observed"]] == 1)
  monoclonal.alleles <- do.call("rbind", alleles[moi.one])

  ## Strategy B. Choose the major allele for each sample and SNV
  # This is the allele supported by the highest number of reads
  # what to do if have same number of ref and alt alleles?
  # Always choose one allele, or assign randomly?
  # N x S matrix of logical values
  high.support <- obs.alt.counts < (coverage / 2)
  # convert to N x S numeric matrix
  sample.major.alleles <- matrix(as.numeric(high.support),
                                 nrow = n.samples,
                                 ncol = n.snps)

  list(true.alleles = true.alleles,
       monoclonal.alleles = monoclonal.alleles,
       sample.major.alleles = sample.major.alleles)

}




