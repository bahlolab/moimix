# Title: moi_simulation.R
# Authors: Katherine Smith, Melanie Bahlo, Stuart Lee
# Description: Function to simulate impact of multiplicity
# of infection in R. Simulation to assess impact of non MOI=1


#' Simulate multiplicity of infection in parasite sequencing data
#'
#' @details This function simulates MOI data and applies two simple MOI
#' handling strategies. It assumes that MOI in a population is distributed
#' according to a Poisson distribution. It requires passing a function as
#' an argument that specifies the minor allele frequency distribution.
#' The sampling distributions available are either truncated exponential
#' or beta. The parameter for these distributions are passed as additional
#' arguments to the
#'
#' @param n.samples integer number of humans sampled for Plasmodium
#' @param n.snps integer number of SNPs examined
#' @param moi.labmda integer expected number of infections per human
#' @param coverage integer number of reads covering each base
#' @param error numeric probability of error in base call
#' @param dirichlet.param integer vector of length 2, specifying mixing
#' parameters for dirichilet distribution
#' @param maf.dist minor allele frequency distribution sampling function
#' (DEFAULT=rtexp)
#' @param ... parameters to be passed to maf.dist See details.
#' @return A list with the following elements
#'  param: a list containing arguments passed to simulateMOI
#'  moi.observed: a vector containing true MOI for each sample
#'  dirichlet.alphas: a vector containing concentration parameters passed
#'  to rdirichlet.
#'  clone.props: a list of n.sample vectors of length K containing the proprotion
#'  of each clone for each sample
#'  reads.per.clone: A list of n.sample matrices of n.snp by K size containing
#'  number of reads observed at each SNP for each clone.
#'  allele.freq: A vector of length n.snps containing observed allele frequency
#'  distribution generated by maf.dist
#'  alt.counts: A matrix of size n.samples by n.snps size containing
#'  number of reads in support of alternate allele.
#'  error.counts: A list of n.sample matrices of K by n.snps size containing
#'  number of sequencing errors per clone.
#'  obs.error.prop: the total observed error proportion
#'  error.alt.change: A matrix of size n.samples by n.snps containing
#'  effect of sequence error on SNP calls
#'  obs.alt.counts: A matrix of size n.samples by n.snps containing the
#'  observed number of reads in support of each SNP.
#' @export
simulateMOI <- function(n.samples,
                        n.snps,
                        moi.lambda,
                        coverage,
                        error,
                        dirichlet.param,
                        maf.dist = rtexp, ...) {



  ### This function simulates MOI data and applies two simple MOI handling strategies
  # error handling
  # - diriichlet parameter vector must be of length 2
  stopifnot(length(dirichlet.param) == 2)
  # error probablity must be a probability
  stopifnot(error >= 0 && error <= 1)

  maf.dist <- match.fun(maf.dist)
  #
  ### I. SIMULATE MULTIPLICITY OF INFECTION DATA

  # N = number of humans sampled for Plasmodium
  # S = number of SNPs examined
  # lambda = expected number of infections, or MOI, per human
  # R = number of reads covering each base
  # a0 = parameter for the alpha vector/concentration parameter for Dirichlet
  # m = parameter for the alpha vector/concentration parameter for Dirichlet
  # mut_rate = parameter for the truncated exponential alternate allele frequency generator
  # epsilon = rate of sequencing error

  # 1. Simulate the MOIs from a Poisson dbn
  # this is a vector of length N
  moi <- rpois(n.samples, moi.lambda) + 1

  # 2. Given the MOI, simulate the true proportions of each clone from a Dirichlet dbn

  # 2a. Obtain the parameters of the Dirichlet dbn for each person
  # this is a list of N vectors of length K
  dirichlet.alphas <- lapply(moi, dirichletAlpha,
                             m = dirichlet.param[1],
                             a0 = dirichlet.param[2])

  # 2b. Simulate the proportion of each clone according to the Dirichlet distribution
  # this is a list of N vectors of length K
  clone.props <- lapply(dirichlet.alphas, rdirichlet)

  # check that the sum of clone proportions is one for each person
  stopifnot(all.equal(sapply(clone.props, sum), rep(1, n.samples)))

  # 3. Simulate the number of reads from each clone from a multinomial dbn
  # this is a list of N matrices of dimension K x S
  reads.per.clone <- sapply(clone.props, rmultinom,
                          n = n.snps,
                          size = coverage)

  # 4. Simulate minor (alternate) allele frequencies from a either
  # truncated exponential distribution with range [0,1] or a beta distribution
  # this is a vector of length S
  aaf <- maf.dist(n = n.snps, ...)

  # 5. Simulate alleles for each clone at each SNP according to a Bernouilli
  # distribution using AAFs from (4)  want a K x S matrix of alleles for each
  # sample, i.e. the haplotypes of each clone store in a list of length N
  # can this loop be replaced by a vectorised expression?
  # Have tried mapply() and outer() with no success
  alleles <- list()

  for (i in 1:n.samples) {
    alleles[[i]] <- sapply(aaf, rbinom,
                           n = moi[i],
                           size = 1)
  }

  # Given the alleles and the reads per clone, what is the number of alt alleles
  # observed in the absence of sequencing error? first compute a length N list of
  # K x S matrices containing the count of alt alleles for each clone, sample and SNP
  x <- mapply("*", reads.per.clone, alleles)

  # then sum over columns and transpose to obtain an N x S matrix
  # containing the count of alt alleles for each sample and SNP
  alt.counts <- t(sapply(x, colSums))

  # 6. Simulate the number of sequencing errors per clone, sample and SNP
  # according to a Binomial distribution.
  # This is a list of N matrices of dimension K x S
  error.counts <- list()

  for (i in 1:n.samples) {
    error.counts[[i]] <- matrix(sapply(reads.per.clone[[i]], rbinom,
                                       n=1,
                                       prob=error),
                                ncol = n.snps)
  }

  # Calculate the observed error proportion
  obs.error.prop <- sum(sapply(error.counts, sum)) / (n.samples * n.snps * coverage)

  # Calculate an N x S matrix indicating how sequencing errors will affect the alt allele counts
  y <- sapply(alleles, function(x) { ifelse(x==1, -1, 1) })

  z <- sapply(y, function(x) { matrix(x, ncol = n.snps) })

  error.alt.change <- t(mapply( function(x,y) { colSums(x*y) },
                                z,
                                error.counts))

  # 7. Compute the observed number of alternate alleles for each sample and SNP
  obs.alt.counts <- alt.counts + error.alt.change

  # Return list containing parameters passed to function and data generated
  # by the simulation
  list(param = list(n.samples = n.samples,
                    n.snps = n.snps,
                    moi.lambda = moi.lambda,
                    coverage = coverage,
                    error = error,
                    dirichlet.param = dirichlet.param,
                    maf.dist = maf.dist ),
       moi.observed = moi,
       dirichlet.alphas = dirichlet.alphas,
       clone.props = clone.props,
       reads.per.clone = reads.per.clone,
       allele.freq = aaf,
       alleles = alleles,
       alt.counts = alt.counts,
       error.counts = error.counts,
       obs.error.prop = obs.error.prop,
       error.alt.change = error.alt.change,
       obs.alt.counts = obs.alt.counts)

}

### II. APPLY MOI STRATEGIES TO SIMULATED DATA

#' Apply handling strategies to simulated data
#'
#' @details This function generates several datasets pertaining
#' to different mulitplicity of infection strategies. Strategy A
#' simply removes all samples with MOI > 1. Strategy B calls the
#' major allele for each sample and single nucleotide variant.
#'
#' @param simMOI.list The list output from simulateMOI
#' @return A list containing three entries:
#'  true.alleles: A matrix containing the true alleles from simulation
#'  monoclonal.alleles: A matrix with MOI=1 samples
#'  sample.major.allels: A matrix containing major alleles for each
#'  sample and SNV
#'
#' @export
handleMOI <- function(simMOI.list) {


  alleles <- simMOI.list[["alleles"]]
  coverage <- simMOI.list[["param"]]["coverage"]
  n.samples <- simMOI.list[["param"]]["n.samples"]
  n.snps <- simMOI.list[["param"]]["n.snps"]
  obs.alt.counts <- simMOI.list[["obs.alt.counts"]]

  # convert the list of true alleles to a matrix
  true.alleles <- do.call("rbind", alleles)

  ## Strategy A. Remove all samples with MOI>1
  # this assumes that MOI is perfectly detectable, which isn't realistic
  moi.one <- which(simMOI.list[["moi.observed"]] == 1)
  monoclonal.alleles <- do.call("rbind", alleles[moi.one])

  ## Strategy B. Choose the major allele for each sample and SNV
  # This is the allele supported by the highest number of reads
  # what to do if have same number of ref and alt alleles?
  # Always choose one allele, or assign randomly?
  # N x S matrix of logical values
  high.support <- obs.alt.counts < (coverage / 2)
  # convert to N x S numeric matrix
  sample.major.alleles <- matrix(as.numeric(high.support),
                                 nrow = n.samples,
                                 ncol = n.snps)

  list(true.alleles = true.alleles,
       monoclonal.alleles = monoclonal.alleles,
       sample.major.alleles = sample.major.alleles)

}




