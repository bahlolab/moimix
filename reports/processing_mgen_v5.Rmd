---
title: "Processing Malaria Genomics Project Pf3k v5"
author: "Stuart Lee"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE,
                      cache.path = "./cache/", fig.path = "./figures/")
# Description: Estimate MAF and determine global minor allele frequencies
# of polymorphisms. Apply coverage threshold and write out MAF estimates,
# heterozygosity estimates, create final mixture GDS file.

devtools::install_github("bahlolab/moimix")
# change this line to run all region datasets
out_file <-  c("processed_data/se_asia.rds", "processed_data/west_africa.rds", 
               "processed_data/central_africa.rds", "processed_data/snp_annotations_clean.rds")
eval_subsets <- all(file.exists(out_file) == FALSE)
```

# Introduction

Here we pre-process the Malaria Genomics Project Pf3k project data
for both IBD analysis within `isoRelate` and to construct a processed ground 
truth data set using the known mixture clones present in the data. 

Up to this point the following steps have been applied to the VCF files
obtained from Pf3k website.

For each chromosome VCF file we applied the following filters using `vcftools`:

* Remove indels
* Keep only biallelic single nucleotide variants on 14 nuclear chromosomes.
* Remove variants if they lie in a Subtelomeric hypervariable or repeat region, 
or in an internal hypervariable or centromere region.
* Remove variants with a log odds score of being true variant versus a false
 variant of 0 or less. (Following the Malaria Genomics guidelines)

After we have processed each chromosome VCF we concatenate them together.

```{bash process-vcf, eval = FALSE}
set -e
vcfdir=/path/to/malaria_gen5/vcf_files
outdir=./raw_data/
tempdir=~/tmp/
# step 1, select only SNPs + VQSLOD > 0, regiontype = core
vcf_chrom=$(find $vcfdir -regex ".*\.*[0-9][0-9]_v3.*.vcf.gz" | sort -u)

for chr in $vcf_chrom 
do
	(stem=$(basename $chr .vcf.gz)
	echo $stem
	vcftools --gzvcf $chr \
	--remove-indels \
	--min-alleles  2 \
	--max-alleles 2 \
	--remove-filtered-all \
	--recode \
	--recode-INFO-all \
	--stdout | bgzip -c > ${tempdir}${stem}.vcf.gz 
	tabix -p vcf ${tempdir}${stem}.vcf.gz) &

done
wait

filtered_vcf=$(find $tempdir -name "*.vcf.gz" | sort -u)

bcftools concat -Oz -o ${outdir}malaria_gen5_biallelic_snps.vcf.gz $filtered_vcf
```

Then we convert the VCF to the GDS format keeping only the tags of interest.
```{r, eval=FALSE}
library(SeqArray)
vcf_file <- "raw_data/malaria_gen5_biallelic_snps.vcf.gz"

vcf_header <- seqVCF_Header(vcf_file)

# recode header format for AD from R to .
vcf_header$format$Number[vcf_header$ID == "AD"] <- "."

# info columns to keep
info.import <- c("AC", "AF", "AN", "BaseQRankSum", "ClippingRankSum",
                 "DP", "FS", "InbreedingCoeff", "MQ", "MQRankSum",
                 "QD", "ReadPosRankSum",
                 "SOR", "VQSLOD", "SNPEFF_AMINO_ACID_CHANGE",
                 "SNPEFF_CODON_CHANGE", "SNPEFF_EFFECT", "SNPEFF_EXON_ID",
                 "SNPEFF_FUNCTIONAL_CLASS", "SNPEFF_GENE_BIOTYPE", 
                 "SNPEFF_GENE_NAME", "SNPEFF_IMPACT", "SNPEFF_TRANSCRIPT_ID")

# format columns to keep
fmt.info <- c("AD", "DP", "GQ", "GT", "PL", "PGT",  "PID")

seqVCF2GDS(vcf_file, "processed_data/malaria_gen5.gds",
           header = vcf_header, 
           info.import = info.import, 
           fmt.import = fmt.info)
```

We now are ready to use the GDS file for analysis in R.
```{r load-vcf}
suppressPackageStartupMessages(library(SeqArray))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(moimix))

# use readonly = FALSE to add sample annotations
mgen <- seqOpen("processed_data/malaria_gen5.gds", readonly = FALSE)

```

The final variant set consists of `r length(seqGetData(mgen, "chromosome"))` 
SNVs segregating by chromosome as follows:
```{r init-counts}
knitr::kable(data.frame(chr = seqGetData(mgen, "chromosome") ) 
             %>% count(chr),
             caption = "SNV counts by chromosome")

```

We have also processed the sample metadata to see how the samples segregate
by geography. Samples with missing country variable correspond to the lab-strains
from the complexity of infection and genetic crosses study.

```{r load-meta}
# load metadata 
library(readr)
mgen_meta <- read_rds("processed_data/mgen_clean.rds")

```

There are `r nrow(mgen_meta %>% filter(!is.na(country)))` total field isolates and the dataset
can be broadly grouped into three broader geographic locations: 

1. West Africa: Senegal, The Gambia, Guinea, Mali, Ghana, Nigeria
2. Central Africa: DR Congo, Malawi
3. South-east Asia: Bangladesh, Cambodia, Vietnam, Thailand, Myanmar, Laos

```{r add-country-labels}
west_africa <- c("The Gambia", "Ghana", "Guinea", "Mali", "Nigeria", "Senegal")
central_africa <- c("DR of the Congo", "Malawi")
se_asia <- c("Bangladesh", "Cambodia", "Laos", "Myanmar", "Thailand", "Vietnam")

mgen_meta$region <- NA
mgen_meta$region[mgen_meta$country %in% west_africa] <- "West Africa"
mgen_meta$region[mgen_meta$country %in% central_africa] <- "Central Africa"
mgen_meta$region[mgen_meta$country %in% se_asia] <- "SE Asia"

field_isolates <- mgen_meta %>% filter(!is.na(country))

knitr::kable(field_isolates %>% count(region, country, site))
# add metadata to GDS file
# first reorder according to sample.id
mgen_meta <- mgen_meta %>% arrange(sample)
if(cnt.gdsn(index.gdsn(mgen, "sample.annotation")) != 4) {
    add.gdsn(index.gdsn(mgen, "sample.annotation"),
             name = "acc", val = mgen_meta$acc)
    add.gdsn(index.gdsn(mgen, "sample.annotation"), 
             name = "region", val =mgen_meta$region)
    add.gdsn(index.gdsn(mgen, "sample.annotation"), 
             name = "country",val = mgen_meta$country)
    add.gdsn(index.gdsn(mgen, "sample.annotation"),
             name = "site", val = mgen_meta$site)
}


```

# Additional sample and SNP filtering
Prior to estimating the minor allele frequencies within a region
and obtaining a final set of SNPs and samples, we need to ensure we are 
confident in the SNP set we have obtained and that samples are of high-quality. 
Although these samples have been processed by there still might be samples 
that are poorly genotyped
and SNVs that aren't polymorphic globally or within the subpopulations.

We first look at the various quality metrics provided by the Haplotype Caller
for variant annotated in the VCF files. Of particular interest is the QD 
MQRanksum, and SOR tags. 


```{r tag-ecdf}
library(ggplot2)
library(grid)
theme_set(theme_bw())
gatk_df <- data.frame(variant.id = seqGetData(mgen, "variant.id"),
                      chr = seqGetData(mgen, "chromosome"),
                      mq =  seqGetData(mgen, "annotation/info/MQ"),
                      mqrank = seqGetData(mgen, "annotation/info/MQRankSum"),
                      qd = seqGetData(mgen, "annotation/info/QD"),
                      sor = seqGetData(mgen, "annotation/info/SOR"))

grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))

print(ggplot(gatk_df, aes(x = mq)) + stat_ecdf(),
      vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
print(ggplot(gatk_df, aes(x = mqrank)) + stat_ecdf(),
      vp = viewport(layout.pos.row = 1, layout.pos.col = 2))
print(ggplot(gatk_df, aes(x = qd)) + stat_ecdf(),
      vp =  viewport(layout.pos.row = 2, layout.pos.col = 1))
print(ggplot(gatk_df, aes(x =  sor)) + stat_ecdf(),
      vp =  viewport(layout.pos.row = 2, layout.pos.col = 2))

# filter based on field samples
# filter based on qd > 20, sor < 1, mqrank > -2 

v_ids <- (gatk_df %>% filter(qd > 15, mq > 50, sor < 1,
                             mqrank > -2 | is.na(mqrank)))$variant.id
```

We see that all variants are supported by high residual mean square mapping
qualities over all samples. The distribution of MQRankSum scores (which is only
computed at heterozygous sites) is centred at 0 with a fat right tail. For this
tag only negative scores are useful since that indicates that the mapping quality
for the alternate allele is low compared to the reference allele. The QD distribution
is relatively symmetric and centred at around 20, most variants have relatively
good ratios of  average quality to average depth. The SOR tag is an odds
ratio score to detect strand bias from a 2 x 2 contingency table using the strands
and alt/ref allele counts as the rows and columns respectively.

We apply some hard filters to all samples,
* QD score > 15
* SOR < 1
* MQRankSum > -2 (allowed to be missing for sites with heterozygous calls)
* MQ > 50

This leaves approximately `r length(v_ids)` SNVs. 

Of the remaining SNVs we then split the data by country and 
apply the following filters

1. Extract SNVs that are covered to at least 5 bases in 90% of samples.
2. Extract SNVs that are polymorphic in the country of interest.
3. Find samples that have 90% of their SNVs covered to at least 5 bases
4. Take intersect set of SNVs that meet criteria 1 and 2 within each country 
across a region. Include samples that meet that criteria within a region. 
5. Using the intersect set of SNVs and compute MAF distributions within each 
country. 
6. Apply a MAF filter of 1% within each country
7. Take intersect set of SNPs that meet 6.) within each country accross a region.

To do this we construct a nested list data structure of where that consist
of three lists per region and lists containing the following for each country:
  
  * sample identifiers meeting our criteria
  * SNP identifiers meeting our criteria
  * Fws estimates
  * MAF estimates

```{r snp-distributions}
mgen_stats <- list()

for (location in unique(field_isolates$region)) {
  mgen_stats[[location]] <- list()
  country_unique <- unique(field_isolates$country[field_isolates$region == location])
  for (country in country_unique) {
    mgen_stats[[location]][[country]] <- list()
    # apply filter first pass
    samples <- field_isolates$sample[field_isolates$country == country]
    # filter first
    seqSetFilter(mgen, sample.id = samples, variant.id = v_ids)
    # SNVs covered to 5 bases overall samples in country
    # first pass at computing MAF
    maf_init <- getMAF(mgen)
    # exclude variants that have MAF <= 0 and snp_5x < 0.9
    variants_step1 <- v_ids[maf_init > 0]
    seqSetFilter(mgen, variant.id = variants_step1)
    
    snp_5x <- perSiteCoverageBySample(mgen, 5L)
    variants_step2 <- variants_step1[snp_5x > 0.9]
    seqSetFilter(mgen, variant.id = variants_step2)
    
    # sample exclusions
    sample_5x <- perSiteCoverageBySNP(mgen, 5L)
    # samples to keep
    samples_step1 <- samples[sample_5x >= 0.9]
    
    seqSetFilter(mgen, sample.id = samples_step1, variant.id = variants_step2)
    # maf final
    maf_final <- getMAF(mgen)
    variants_step3 <- seqGetData(mgen, "variant.id")
    # estimate Fws on subset region
    # fws_final 
    fws_final <- getFws(mgen)
    
    maf_filter <- variants_step3[maf_final > 0.01] 
    # collect data 
    mgen_stats[[location]][[country]]$samples <- samples_step1
    mgen_stats[[location]][[country]]$snps <- maf_filter
    mgen_stats[[location]][[country]]$fws <- fws_final
    # create plots
    par(mfrow = c(2,2))
    
    plot(ecdf(snp_5x),
     xlab = "Proportion of SNPs", 
     ylab = "Cumulative proportion of of samples",
     main = paste("ECDF coverage at 5x for", country))
    
    plot(ecdf(sample_5x),
     xlab = "Proportion of samples",
     ylab = "Cumulative proportion of SNPs",
     main= paste("ECDF coverage at 5x for", country))
    
    plot(ecdf(maf_final), breaks = 100,
         xlab =  "MAF",
         main = paste("MAF distribution", country))
    
    plot(ecdf(fws_final),
         xlab = "Fws",
         main = paste("Fws distribution for", country))
    dev.off()
    # reset filter
    seqSetFilter(mgen)
  }
}

```




```{r snp-missingess, cache=TRUE}

```{r coverage-filtering, cache=TRUE}
# sample coverage 
sample_5x <- perSiteCoverageBySNP(mgen, 5L)
sample_10x <- perSiteCoverageBySNP(mgen, 10L)
sample_20x <- perSiteCoverageBySNP(mgen, 20L)

cbbPalette <- c("#000000", "#E69F00", "#56B4E9")

plot(ecdf(sample_5x),
     col = cbbPalette[1],
     xlab = "Proportion of samples",
     ylab = "Cumulative proportion of SNPs",
     main = "")
lines(ecdf(sample_10x), col = cbbPalette[2])
lines(ecdf(sample_20x), col = cbbPalette[3])
legend('left',  c('5x', '10x', '20x'), fill=cbbPalette, border=NA)
```
From the ECDF coverage plots we find that more than 90\% of samples 
have at least 90\% of theirs SNPs covered to 5 bases. Moreover, 90\% of samples
have at least 70\% of their SNPs covered to 10 bases and 90\% of samples have at
least 60\% of their SNPs covered by 20 bases.


```{r sample-missingness, cache=TRUE}

# snp coverage by number of samples covered up to 5x, 10x, 10x
snp_5x <- perSiteCoverageBySample(mgen, 5L)
snp_10x <- perSiteCoverageBySample(mgen, 10L)
snp_20x <- perSiteCoverageBySample(mgen, 20L)


plot(ecdf(snp_20x),
     col = cbbPalette[1], xlab = "Proportion of SNPs", 
     ylab = "Cumulative proportion of of samples",
     main = "")
lines(ecdf(snp_10x), col = cbbPalette[2])
lines(ecdf(snp_20x), col = cbbPalette[3])
legend('left', c('5x', '10x', '20x'), fill=cbbPalette, border=NA)

```

Similarly, from the ECDF coverage plots we see that more than 90\% of the SNPs 
are covered to at least 5 bases in 90\% of samples. 
While 60\% of SNPs are covered up to 10 bases in 90\% of samples and 30\% of SNP
s are covered up to 20 bases in 90\% of the samples.
 
Since for this analysis we are more interested in evaluating known variants
(i.e. true positive variants) we applied some hard filtering to this dataset:

* select variants where at least 90% of SNPs are covered to at least 10 bases
in all samples.
* select samples where samples have at least 90\% of their SNPs
covered by at least 5 reads.

```{r apply-filters}
variant_filter <- v_ids[which(snp_10x > 0.9)]


samples_to_keep <- field_isolates$sample[which(sample_5x > 0.9)]

seqSetFilter(mgen, sample.id = samples_to_keep, variant.id = variant_filter)
```

This leaves us with `r length(samples_to_keep)` samples and 
`r length(variant_filter)` variants. The samples segregate by region as follows:

```{r group-region}
filtered_fi <- field_isolates %>% filter(sample %in% samples_to_keep)
knitr::kable(filtered_fi %>% count(region, country))
```

And the variants segregate by chromosome as follows:
```{r group-chr}
coords <- getCoordinates(mgen)

knitr::kable(coords %>% count(chromosome))
```

We save the global dataset as follows by extracting genotype calls
(setting the heterozygous calls to missing at the moment) and the allele counts.
# Global data set
```{r extract-global}
ped_all <- extractPED(mgen, use.hets = FALSE)

acounts <- alleleCounts(mgen)

write_rds(ped_all, "processed_data/mgen_all_ped.rds")
write_rds(acounts, "processed_data/mgen_all_allele_counts.rds")

```



# Constructing three region specific data subsets

For the IBD analysis we require filters on the variants to ensure the SNPs
have high enough MAFs and to annotate samples that are putatively clonal. 

To do this we perform the following steps
1. Subset the calls by geographic region defined above.
2. Estimate the $F_{ws}$ metric to annotate samples as either single clones 
or multiple clone infections. We use this for a quick proxy for multiple infections,
before assessing this in more detail using `moimix`.
3. Estimate the MAFs directly from read-count data and select variants that
are polymorphic in that region. 

We also save the PED and MAP file as an R objects to speed up write-out.

## Central Africa

```{r central-africa, eval = eval_subsets}
# get central africa IDs
centr_afr <- seqGetData(mgen, "sample.id")[seqGetData(mgen, "sample.annotation/region") == "Central Africa"]
# filter gds
seqSetFilter(mgen, sample.id = centr_afr, variant.id = variant_filter)

# estimate MAF
maf_ca <- getMAF(mgen)
# remove variants that are not polymorphic at all in this region (MAF == 0)
snp_ca <- variant_filter[maf_ca > 0]

hist(maf_ca[snp_ca], breaks = 100)
seqSetFilter(mgen, sample.id = centr_afr, variant.id = snp_ca)
# estimate Fws metric
fws_central_africa <- getFws(mgen)
moi_ca <- data.frame(sample = centr_afr, fws = fws_central_africa, 
                     moi = ifelse(fws_central_africa > 0.95, 1, 2))

hist(fws_central_africa, breaks = 100)

plink_ca <- extractPED(mgen, moi.estimates = moi_ca$moi)

write_rds(plink_ca, "processed_data/central_africa.rds")

seqSetFilter(mgen)

```

## West Africa

```{r west-africa, eval = eval_subsets}
# get central africa IDs
west_afr <- seqGetData(mgen, "sample.id")[seqGetData(mgen, "sample.annotation/region") == "West Africa"]
# filter gds
seqSetFilter(mgen, sample.id = west_afr, variant.id = variant_filter)

# estimate MAF
maf_wa <- getMAF(mgen)
# remove variants that are not polymorphic at all in this region (MAF == 0)
snp_wa <- variant_filter[maf_ca > 0]
hist(maf_wa[snp_wa], breaks = 100)

seqSetFilter(mgen, sample.id = west_afr, variant.id = snp_wa)
# estimate Fws metric
fws_west_africa <- getFws(mgen)
moi_wa <- data.frame(sample = west_afr, fws = fws_west_africa, 
                     moi = ifelse(fws_west_africa > 0.95, 1, 2))


hist(fws_west_africa, breaks = 100)

plink_wa <- extractPED(mgen, moi.estimates = moi_wa$moi)

write_rds(plink_wa, "processed_data/west_africa.rds")
seqSetFilter(mgen)
```

## SE Asia

```{r se-asia, eval = eval_subsets}
# get central africa IDs
se_asia <- seqGetData(mgen, "sample.id")[seqGetData(mgen, 
                                                    "sample.annotation/region") == "SE Asia"]
# filter gds
seqSetFilter(mgen, sample.id = se_asia, variant.id = variant_filter)

# estimate MAF
maf_sea <- getMAF(mgen)
# remove variants that are not polymorphic at all in this region (MAF == 0)
snp_sea <- variant_filter[maf_sea > 0]
hist(maf_sea[snp_sea], breaks = 100)

seqSetFilter(mgen, sample.id = se_asia, variant.id = snp_sea)
# estimate Fws metric
fws_se_asia <- getFws(mgen)
moi_sea <- data.frame(sample = se_asia, fws = fws_se_asia, 
                     moi = ifelse(fws_se_asia > 0.95, 1, 2))

hist(fws_se_asia, breaks = 100)

plink_sea <- extractPED(mgen, moi.estimates = moi_sea$moi)

write_rds(plink_sea, "processed_data/se_asia.rds")

seqSetFilter(mgen)
```

# Save annotation sets
We also save the variant annotations across all populations.

```{r gene-ids, eval = eval_subsets}
seqSetFilter(mgen, variant.id = variant_filter)

annotations <- data.frame(chr = seqGetData(mgen, "chromosome"),
                          pos = seqGetData(mgen, "position"),
                          gene_name = seqGetData(mgen, "annotation/info/SNPEFF_GENE_NAME"),
                          gene_biotype = seqGetData(mgen, "annotation/info/SNPEFF_GENE_BIOTYPE"),
                          snp_effect = seqGetData(mgen, "annotation/info/SNPEFF_AMINO_ACID_CHANGE"),
                          snp_functional_class = seqGetData(mgen, "annotation/info/SNPEFF_EFFECT"), 
                          snp_aa_change = seqGetData(mgen, "annotation/info/SNPEFF_AMINO_ACID_CHANGE"),
                          snp_codon_change = seqGetData(mgen, "annotation/info/SNPEFF_CODON_CHANGE"),
                          exon_id = seqGetData(mgen, "annotation/info/SNPEFF_EXON_ID"),
                          transcript_id = seqGetData(mgen, "annotation/info/SNPEFF_TRANSCRIPT_ID"))

# counts
knitr::kable(annotations %>% 
                 count(snp_functional_class, gene_biotype))

write_rds(annotations, "processed_data/snp_annotations_clean.rds")

```


# Extracting mixture data 

To construct polymorphic markers for the known mixture strains we extract a set
of high MAF and high heterzygous set of global markers from the global field
isolate sets. 

```{r mixture-step-1, fig.show='hold'}
seqSetFilter(mgen, sample.id = samples_to_keep, variant.id = variant_filter)

maf_all <- getMAF(mgen)


het_all <- getHeterozygosity(mgen)

plot(ecdf(maf_all))
plot(ecdf(het_all))

```

We see that as observed in the other populations the MAF distribution is
biased to rare alleles. If we choose SNVs that are heterozygous, this
should give us a cleaner signal for detecting MOI.

```{r mixtures-step-2}
mix_inform_snps <- variant_filter[maf_all > 0.01 & het_all > 0.01]

# read in mixture metadata
mixture <- read_rds("processed_data/mixtures_all.rds")

seqSetFilter(mgen, variant.id = mix_inform_snps, sample.id = mixture$sample)

```

We also plot the BAF frequencies to see if the signal remains in this
reduced variant set.

```{r plot-baf}
bf <- bafMatrix(mgen)

for(sample in mixture$sample) {
    plot(bf, sample)
}

```

Finally, we export the mixture data to a GDS file and make it available to 
`moimix`.

```{r mixture-export}
seqExport(mgen, "processed_data/mixtures_clean.gds")

```
# Appendix

```{r sessionInfo}
# tidy up gds
seqSetFilter(mgen)
seqClose(mgen)
# cleanup.gds("processed_data/malaria_gen5.gds")

sessionInfo()
```
