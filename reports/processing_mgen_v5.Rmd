---
title: "Processing Malaria Genomics Project Pf3k v5"
author: "Stuart Lee"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE,
                      cache.path = "./cache/", fig.path = "./figures/")
# Description: Estimate MAF and determine global minor allele frequencies
# of polymorphisms. Apply coverage threshold and write out MAF estimates,
# heterozygosity estimates, create final mixture GDS file.
devtools::install_github("bahlolab/moimix")
```

# Introduction

Here we pre-process the Malaria Genomics Project Pf3k project data
for both IBD analysis within `isoRelate` and to construct a processed ground 
truth data set using the known mixture clones present in the data. 

Up to this point the following steps have been applied to the VCF files
obtained from Pf3k website.

For each chromosome VCF file we applied the following filters using `vcftools`:

* Remove indels
* Keep only biallelic single nucleotide variants on 14 nuclear chromosomes.
* Remove variants if they lie in a Subtelomeric hypervariable or repeat region, 
or in an internal hypervariable or centromere region.
* Remove variants with a log odds score of being true variant versus a false
 variant of 0 or less. (Following the Malaria Genomics guidelines)

After we have processed each chromosome VCF we concatenate them together.

```{bash process-vcf, eval = FALSE}
set -e
vcfdir=/path/to/malaria_gen5/vcf_files
outdir=./raw_data/
tempdir=~/tmp/
# step 1, select only SNPs + VQSLOD > 0, regiontype = core
vcf_chrom=$(find $vcfdir -regex ".*\.*[0-9][0-9]_v3.*.vcf.gz" | sort -u)

for chr in $vcf_chrom 
do
	(stem=$(basename $chr .vcf.gz)
	echo $stem
	vcftools --gzvcf $chr \
	--remove-indels \
	--min-alleles  2 \
	--max-alleles 2 \
	--remove-filtered-all \
	--recode \
	--recode-INFO-all \
	--stdout | bgzip -c > ${tempdir}${stem}.vcf.gz 
	tabix -p vcf ${tempdir}${stem}.vcf.gz) &

done
wait

filtered_vcf=$(find $tempdir -name "*.vcf.gz" | sort -u)

bcftools concat -Oz -o ${outdir}malaria_gen5_biallelic_snps.vcf.gz $filtered_vcf
```

Then we convert the VCF to the GDS format keeping only the tags of interest.
```{r, eval=FALSE}
library(SeqArray)
vcf_file <- "raw_data/malaria_gen5_biallelic_snps.vcf.gz"

vcf_header <- seqVCF_Header(vcf_file)

# recode header format for AD from R to .
vcf_header$format$Number[vcf_header$ID == "AD"] <- "."

# info columns to keep
info.import <- c("AC", "AF", "AN", "BaseQRankSum", "ClippingRankSum",
                 "DP", "FS", "InbreedingCoeff", "MQ", "MQRankSum",
                 "QD", "ReadPosRankSum",
                 "SOR", "VQSLOD", "SNPEFF_AMINO_ACID_CHANGE",
                 "SNPEFF_CODON_CHANGE", "SNPEFF_EFFECT", "SNPEFF_EXON_ID",
                 "SNPEFF_FUNCTIONAL_CLASS", "SNPEFF_GENE_BIOTYPE", 
                 "SNPEFF_GENE_NAME", "SNPEFF_IMPACT", "SNPEFF_TRANSCRIPT_ID")

# format columns to keep
fmt.info <- c("AD", "DP", "GQ", "GT", "PL", "PGT",  "PID")

seqVCF2GDS(vcf_file, "processed_data/malaria_gen5.gds",
           header = vcf_header, 
           info.import = info.import, 
           fmt.import = fmt.info)
```

We now are ready to use the GDS file for analysis in R.
```{r load-vcf}
suppressPackageStartupMessages(library(SeqArray))
suppressPackageStartupMessages(library(dplyr))
suppressPacakgeStartupMessages(library(moimix))

# use readonly = FALSE to add sample annotations
mgen <- seqOpen("processed_data/malaria_gen5.gds", readonly = FALSE)


```

The final variant set consists of `r length(seqGetData(mgen, "chromosome"))` 
SNVs segregating by chromosome as follows:
```{r init-counts}
knitr::kable(data.frame(chr = seqGetData(mgen, "chromosome") ) 
             %>% count(chr),
             caption = "SNV counts by chromosome")

```

We have also processed the sample metadata to see how the samples segregate
by geography. Samples with missing country variable correspond to the lab-strains
from the complexity of infection and genetic crosses study.

```{r load-meta}
# load metadata 
library(readr)
mgen_meta <- read_rds("processed_data/mgen_clean.rds")

```

There are `r nrow(mgen_meta %>% filter(!is.na(country)))` total field isolates and the dataset
can be broadly grouped into three broader geographic locations: 

1. West Africa: Senegal, The Gambia, Guinea, Mali, Ghana, Nigeria
2. Central Africa: DR Congo, Malawi
3. South-east Asia: Bangladesh, Cambodia, Vietnam, Thailand, Myanmar, Laos

```{r add-country-labels}
west_africa <- c("The Gambia", "Ghana", "Guinea", "Mali", "Nigeria", "Senegal")
central_africa <- c("DR of the Congo", "Malawi")
se_asia <- c("Bangladesh", "Cambodia", "Laos", "Myanmar", "Thailand", "Vietnam")

mgen_meta$region <- NA
mgen_meta$region[mgen_meta$country %in% west_africa] <- "West Africa"
mgen_meta$region[mgen_meta$country %in% central_africa] <- "Central Africa"
mgen_meta$region[mgen_meta$country %in% se_asia] <- "SE Asia"

field_isolates <- mgen_meta %>% filter(!is.na(country))

knitr::kable(field_isolates %>% count(region, country, site))
# add metadata to GDS file
# first reorder according to sample.id
mgen_meta <- mgen_meta %>% arrange(sample)
if(cnt.gdsn(index.gdsn(mgen, "sample.annotation")) != 4) {
    add.gdsn(index.gdsn(mgen, "sample.annotation"),
             name = "acc", val = mgen_meta$acc)
    add.gdsn(index.gdsn(mgen, "sample.annotation"), 
             name = "region", val =mgen_meta$region)
    add.gdsn(index.gdsn(mgen, "sample.annotation"), 
             name = "country",val = mgen_meta$country)
    add.gdsn(index.gdsn(mgen, "sample.annotation"),
             name = "site", val = mgen_meta$site)
}


```

# Additional sample and SNP filtering
Prior to estimating the minor allele frequencies and obtaining a final set
of SNPs and samples. We need to ensure we are confident in the SNP set we have
obtained and that samples are of high-quality. Although these samples
have been processed by there still might be samples that are poorly genotyped
and SNVs that aren't polymorphic globally or within the subpopulations.

We first look at the various quality metrics provided by the Haplotype Caller
for variant annotated in the VCF files. Of particular interest is the QD 
MQRanksum, and SOR tags. 


```{r tag-ecdf}
library(ggplot2)
library(grid)
theme_set(theme_bw())
gatk_df <- data.frame(variant.id = seqGetData(mgen, "variant.id"),
                      chr = seqGetData(mgen, "chromosome"),
                      mq =  seqGetData(mgen, "annotation/info/MQ"),
                      mqrank = seqGetData(mgen, "annotation/info/MQRankSum"),
                      qd = seqGetData(mgen, "annotation/info/QD"),
                      sor = seqGetData(mgen, "annotation/info/SOR"))

grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))

print(ggplot(gatk_df, aes(x = mq)) + stat_ecdf(),
      vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
print(ggplot(gatk_df, aes(x = mqrank)) + stat_ecdf(),
      vp = viewport(layout.pos.row = 1, layout.pos.col = 2))
print(ggplot(gatk_df, aes(x = qd)) + stat_ecdf(),
      vp =  viewport(layout.pos.row = 2, layout.pos.col = 1))
print(ggplot(gatk_df, aes(x =  sor)) + stat_ecdf(),
      vp =  viewport(layout.pos.row = 2, layout.pos.col = 2))

```

We see that all variants are supported by high residual mean square mapping
qualities over all samples. The distribution of MQRankSum scores (which is only
computed at heterozygous sites) is centred at 0 with a fat right tail. For this
tag only negative scores are useful since that indicates that the mapping quality
for the alternate allele is low compared to the reference allele. The QD distribution
is relatively symmetric and centred at around 20, most variants have relatively
good ratios of  average quality to average depth. The SOR tag is an odds
ratio score to detect strand bias from a 2 x 2 contingency table using the strands
and alt/ref allele counts as the rows and columns respectively.

We apply some hard filters first before looking at coverage distributions,
* QD score > 15
* SOR < 1
* MQRankSum > -2

Next we look at the empirical cumulative distribution functions (ECDF) at:

* SNPs covered to x bases at different thresholds where x=5, 7, 10
* Samples where the proportion of SNPs covered to x bases at different thresholds
where x=5,7,10 
```{r snp-missingess, cache=TRUE}
# filter based on field samples
# filter based on qd > 20, sor > 1, mqrank > -2 
v_ids <- (gatk_df %>% filter(qd > 20, sor > 1 | is.na(sor), mqrank > -2 | is.na(mqrank)))$variant.id
seqSetFilter(mgen, sample.id = field_isolates$sample, variant.id = v_ids)

# sample coverage 
sample_5x <- perSiteCoverageBySNP(mgen, 5L)
sample_10x <- perSiteCoverageBySNP(mgen, 10L)
sample_20x <- perSiteCoverageBySNP(mgen, 20L)

cbbPalette <- c("#000000", "#E69F00", "#56B4E9")

plot(ecdf(sample_5x),
     col = cbbPalette[1],
     xlab = "Proportion of samples",
     ylab = "Cumulative proportion of SNPs",
     main = "")
lines(ecdf(sample_10x), col = cbbPalette[2])
lines(ecdf(sample_20x), col = cbbPalette[3])
legend('left',  c('5x', '10x', '20x'), fill=cbbPalette, border=NA)

```
From the ECDF coverage plots we find that more than 90\% of samples 
have at least 90\% of theirs SNPs covered to 5 bases. Moreover, 90\% of samples
have at least 70\% of their SNPs covered to 10 bases and 90\% of samples have at
least 60\% of their SNPs covered by 20 bases.


```{r sample-missingness, cache=TRUE}

# snp coverage by number of samples covered up to 5x, 10x, 10x
snp_5x <- perSiteCoverageBySample(mgen, 5L)
snp_10x <- perSiteCoverageBySample(mgen, 10L)
snp_20x <- perSiteCoverageBySample(mgen, 20L)


plot(ecdf(snp_20x),
     col = cbbPalette[1], xlab = "Proportion of SNPs", 
     ylab = "Cumulative proportion of of samples",
     main = "")
lines(ecdf(snp_10x), col = cbbPalette[2])
lines(ecdf(snp_20x), col = cbbPalette[3])
legend('left', c('5x', '10x', '20x'), fill=cbbPalette, border=NA)

```

Similarly, from the ECDF coverage plots we see that more than 90\% of the SNPs 
are covered to at least 5 bases in 90\% of samples. 
While 60\% of SNPs are covered up to 10 bases in 90\% of samples and 30\% of SNP
s are covered up to 20 bases in 90\% of the samples.
 
Since for this analysis we are more interested in evaluating known variants
(i.e. true positive variants) we applied some hard filtering to this dataset:

* select variants where at least 80% of SNPs are covered to at least 20 bases
in all samples.
* select samples where samples have at least 90\% of their SNPs
covered by at least 5 reads.

```{r apply-filters}
variant_filter <- v_ids[which(snp_20x > 0.8)]


samples_to_keep <- field_isolates$sample[which(sample_5x > 0.9)]

seqSetFilter(mgen, sample.id = samples_to_keep, variant.id = variant_filter)
```

This leaves us with `r length(samples_to_keep)` samples and 
`r length(variant_filter)` variants. The samples segregate by region as follows:

```{r group-region}
filtered_fi <- field_isolates %>% filter(sample %in% samples_to_keep)
knitr::kable(filtered_fi %>% count(region, country))
```

And the variants segregate by chromosome as follows:
```{r group-chr}
coords <- getCoordinates(mgen)

knitr::kable(coords %>% count(chromosome))
```

# Constructing three region specific data subsets

For the IBD analysis we require filters on the variants to ensure the SNPs
have high enough MAFs and to annotate samples that are putatively clonal. 

To do this we perform the following steps
1. Subset the calls by geographic region defined above.
2. Estimate the $F_{ws}$ metric to annotate samples as either single clones 
or multiple clone infections. We use this for a quick proxy for multiple infections,
before assessing this in more detail using `moimix`.
3. Estimate the MAFs directly from read-count data and select variants that
are polymorphic in that region. 

We also save the PED and MAP file as an R objects to speed up write-out.

## Central Africa

```{r central-africa}
# get central africa IDs
centr_afr <- seqGetData(mgen, "sample.id")[seqGetData(mgen, "sample.annotation/region") == "Central Africa"]
# filter gds
seqSetFilter(mgen, sample.id = centr_afr, variant.id = variant_filter)

# estimate MAF
maf_ca <- getMAF(mgen)
# remove variants that are not polymorphic at all in this region (MAF == 0)
snp_ca <- variant_filter[maf_ca > 0]

hist(maf_ca[snp_ca], breaks = 100)
seqSetFilter(mgen, sample.id = centr_afr, variant.id = snp_ca)
# estimate Fws metric
fws_central_africa <- getFws(mgen)
moi_ca <- data.frame(sample = centr_afr, fws = fws_central_africa, 
                     moi = ifelse(fws_central_africa > 0.95, 1, 2))

hist(fws_central_africa, breaks = 100)

plink_ca <- extractPED(mgen, moi.estimates = moi_ca$moi)

write_rds(plink_ca, "processed_data/central_africa.rds")

seqSetFilter(mgen)

```

## West Africa
```{r west-africa}
# get central africa IDs
west_afr <- seqGetData(mgen, "sample.id")[seqGetData(mgen, "sample.annotation/region") == "West Africa"]
# filter gds
seqSetFilter(mgen, sample.id = west_afr, variant.id = variant_filter)

# estimate MAF
maf_wa <- getMAF(mgen)
# remove variants that are not polymorphic at all in this region (MAF == 0)
snp_wa <- variant_filter[maf_ca > 0]
hist(maf_wa[snp_wa], breaks = 100)

seqSetFilter(mgen, sample.id = west_afr, variant.id = snp_wa)
# estimate Fws metric
fws_west_africa <- getFws(mgen)
moi_wa <- data.frame(sample = west_afr, fws = fws_west_africa, 
                     moi = ifelse(fws_central_africa > 0.95, 1, 2))


hist(fws_west_africa, breaks = 100)

plink_wa <- extractPED(mgen, moi.estimates = moi_wa$moi)

write_rds(plink_wa, "processed_data/west_africa.rds")
seqSetFilter(mgen)
```
## SE Asia
```{r se-asia}
# get central africa IDs
se_asia <- seqGetData(mgen, "sample.id")[seqGetData(mgen, 
                                                    "sample.annotation/region") == "SE Asia"]
# filter gds
seqSetFilter(mgen, sample.id = se_asia, variant.id = variant_filter)

# estimate MAF
maf_sea <- getMAF(mgen)
# remove variants that are not polymorphic at all in this region (MAF == 0)
snp_sea <- variant_filter[maf_sea > 0]
hist(maf_sea[snp_sea], breaks = 100)

seqSetFilter(mgen, sample.id = se_asia, variant.id = snp_sea)
# estimate Fws metric
fws_se_asia <- getFws(mgen)
moi_sea <- data.frame(sample = se_asia, fws = fws_se_asia, 
                     moi = ifelse(fws_central_africa > 0.95, 1, 2))

hist(fws_sea_asia, breaks = 100)

extractPED(mgen, 
           moi.estimates = moi_sea$moi)

seqSetFilter(mgen)
```

# Save annotation sets
We also save the variant annotations across all populations.

```{r gene-ids}
seqSetFilter(mgen, variant.id = variant_filter)

annotations <- data.frame(chr = seqGetData(mgen, "chromosome"),
                          pos = seqGetData(mgen, "position"),
                          gene_name = seqGetData(mgen, "annotation/info/SNPEFF_GENE_NAME"),
                          gene_biotype = seqGetData(mgen, "annotation/info/SNPEFF_GENE_BIOTYPE"),
                          snp_effect = seqGetData(mgen, "annotation/info/SNPEFF_AMINO_ACID_CHANGE"),
                          snp_functional_class = seqGetData(mgen, "annotation/info/SNPEFF_EFFECT"), 
                          snp_aa_change = seqGetData(mgen, "annotation/info/SNPEFF_AMINO_ACID_CHANGE"),
                          snp_codon_change = seqGetData(mgen, "annotation/info/SNPEFF_CODON_CHANGE"),
                          exon_id = seqGetData(mgen, "annotation/info/SNPEFF_EXON_ID"),
                          transcript_id = seqGetData(mgen, "annotation/info/SNPEFF_TRANSCRIPT_ID"))

# counts
knitr::kable(annotations %>% 
                 count(snp_functional_class, gene_biotype))

write_rds(annotations, "processed_data/snp_annotations_clean.rds")

```

# Appendix
```{r sessionInfo}
seqClose(mgen)
# cleanup.gds("processed_data/malaria_gen5.gds")

sessionInfo()
```
