---
title: "Processing Malaria Genomics Project Pf3k v5"
author: "Stuart Lee"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE,
                      cache.path = "./cache/", fig.path = "./figures/")
# Description: Estimate MAF and determine global minor allele frequencies
# of polymorphisms. Apply coverage threshold and write out MAF estimates,
# heterozygosity estimates, create final mixture GDS file.

devtools::install_github("bahlolab/moimix")
```

# Introduction

Here we pre-process the Malaria Genomics Project Pf3k project data
for both IBD analysis within `isoRelate` and to construct a processed ground 
truth data set using the known mixture clones present in the data. 

Up to this point the following steps have been applied to the VCF files
obtained from Pf3k website.

For each chromosome VCF file we applied the following filters using `vcftools`:

* Remove indels
* Keep only biallelic single nucleotide variants on 14 nuclear chromosomes.
* Remove variants if they lie in a Subtelomeric hypervariable or repeat region, 
or in an internal hypervariable or centromere region.
* Remove variants with a log odds score of being true variant versus a false
 variant of 0 or less. (Following the Malaria Genomics guidelines)

After we have processed each chromosome VCF we concatenate them together.

```{bash process-vcf, eval = FALSE}
set -e
vcfdir=/path/to/malaria_gen5/vcf_files
outdir=./raw_data/
tempdir=~/tmp/
# step 1, select only SNPs + VQSLOD > 0, regiontype = core
vcf_chrom=$(find $vcfdir -regex ".*\.*[0-9][0-9]_v3.*.vcf.gz" | sort -u)

for chr in $vcf_chrom 
do
	(stem=$(basename $chr .vcf.gz)
	echo $stem
	vcftools --gzvcf $chr \
	--remove-indels \
	--min-alleles  2 \
	--max-alleles 2 \
	--remove-filtered-all \
	--recode \
	--recode-INFO-all \
	--stdout | bgzip -c > ${tempdir}${stem}.vcf.gz 
	tabix -p vcf ${tempdir}${stem}.vcf.gz) &

done
wait

filtered_vcf=$(find $tempdir -name "*.vcf.gz" | sort -u)

bcftools concat -Oz -o ${outdir}malaria_gen5_biallelic_snps.vcf.gz $filtered_vcf
```

Then we convert the VCF to the GDS format keeping only the tags of interest.
```{r, eval=FALSE}
library(SeqArray)
vcf_file <- "raw_data/malaria_gen5_biallelic_snps.vcf.gz"

vcf_header <- seqVCF_Header(vcf_file)

# recode header format for AD from R to .
vcf_header$format$Number[vcf_header$ID == "AD"] <- "."

# info columns to keep
info.import <- c("AC", "AF", "AN", "BaseQRankSum", "ClippingRankSum",
                 "DP", "FS", "InbreedingCoeff", "MQ", "MQRankSum",
                 "QD", "ReadPosRankSum",
                 "SOR", "VQSLOD", "SNPEFF_AMINO_ACID_CHANGE",
                 "SNPEFF_CODON_CHANGE", "SNPEFF_EFFECT", "SNPEFF_EXON_ID",
                 "SNPEFF_FUNCTIONAL_CLASS", "SNPEFF_GENE_BIOTYPE", 
                 "SNPEFF_GENE_NAME", "SNPEFF_IMPACT", "SNPEFF_TRANSCRIPT_ID")

# format columns to keep
fmt.info <- c("AD", "DP", "GQ", "GT", "PL", "PGT",  "PID")

seqVCF2GDS(vcf_file, "processed_data/malaria_gen5.gds",
           header = vcf_header, 
           info.import = info.import, 
           fmt.import = fmt.info)
```

We now are ready to use the GDS file for analysis in R.
```{r load-vcf}
suppressPackageStartupMessages(library(SeqArray))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(moimix))

# use readonly = FALSE to add sample annotations
mgen <- seqOpen("processed_data/malaria_gen5.gds", readonly = FALSE)

```

The final variant set consists of `r length(seqGetData(mgen, "chromosome"))` 
SNVs segregating by chromosome as follows:
```{r init-counts}
knitr::kable(data.frame(chr = seqGetData(mgen, "chromosome") ) 
             %>% count(chr),
             caption = "SNV counts by chromosome")

```

We have also processed the sample metadata to see how the samples segregate
by geography. Samples with missing country variable correspond to the lab-strains
from the complexity of infection and genetic crosses study.

```{r load-meta}
# load metadata 
library(readr)
mgen_meta <- read_rds("processed_data/mgen_clean.rds")

```

There are `r nrow(mgen_meta %>% filter(!is.na(country)))` total field isolates and the dataset
can be broadly grouped into three broader geographic locations: 

1. West Africa: Senegal, The Gambia, Guinea, Mali, Ghana, Nigeria
2. Central Africa: DR Congo, Malawi
3. South-east Asia: Bangladesh, Cambodia, Vietnam, Thailand, Myanmar, Laos

```{r add-country-labels}
west_africa <- c("The Gambia", "Ghana", "Guinea", "Mali", "Nigeria", "Senegal")
central_africa <- c("DR of the Congo", "Malawi")
se_asia <- c("Bangladesh", "Cambodia", "Laos", "Myanmar", "Thailand", "Vietnam")

mgen_meta$region <- NA
mgen_meta$region[mgen_meta$country %in% west_africa] <- "West Africa"
mgen_meta$region[mgen_meta$country %in% central_africa] <- "Central Africa"
mgen_meta$region[mgen_meta$country %in% se_asia] <- "SE Asia"

field_isolates <- mgen_meta %>% filter(!is.na(country))

knitr::kable(field_isolates %>% count(region, country, site))
# add metadata to GDS file
# first reorder according to sample.id
mgen_meta <- mgen_meta %>% arrange(sample)
if(cnt.gdsn(index.gdsn(mgen, "sample.annotation")) != 4) {
    add.gdsn(index.gdsn(mgen, "sample.annotation"),
             name = "acc", val = mgen_meta$acc)
    add.gdsn(index.gdsn(mgen, "sample.annotation"), 
             name = "region", val =mgen_meta$region)
    add.gdsn(index.gdsn(mgen, "sample.annotation"), 
             name = "country",val = mgen_meta$country)
    add.gdsn(index.gdsn(mgen, "sample.annotation"),
             name = "site", val = mgen_meta$site)
}


```

# Additional sample and SNP filtering
Prior to estimating the minor allele frequencies within a region
and obtaining a final set of SNPs and samples, we need to ensure we are 
confident in the SNP set we have obtained and that samples are of high-quality. 
Although these samples have been processed by there still might be samples 
that are poorly genotyped
and SNVs that aren't polymorphic globally or within the subpopulations.

We first look at the various quality metrics provided by the Haplotype Caller
for variant annotated in the VCF files. Of particular interest is the QD 
MQRanksum, and SOR tags. 


```{r tag-ecdf}
library(ggplot2)
library(grid)
theme_set(theme_bw())
gatk_df <- data.frame(variant.id = seqGetData(mgen, "variant.id"),
                      chr = seqGetData(mgen, "chromosome"),
                      mq =  seqGetData(mgen, "annotation/info/MQ"),
                      mqrank = seqGetData(mgen, "annotation/info/MQRankSum"),
                      qd = seqGetData(mgen, "annotation/info/QD"),
                      sor = seqGetData(mgen, "annotation/info/SOR"))

grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 2)))

print(ggplot(gatk_df, aes(x = mq)) + stat_ecdf(),
      vp = viewport(layout.pos.row = 1, layout.pos.col = 1))
print(ggplot(gatk_df, aes(x = mqrank)) + stat_ecdf(),
      vp = viewport(layout.pos.row = 1, layout.pos.col = 2))
print(ggplot(gatk_df, aes(x = qd)) + stat_ecdf(),
      vp =  viewport(layout.pos.row = 2, layout.pos.col = 1))
print(ggplot(gatk_df, aes(x =  sor)) + stat_ecdf(),
      vp =  viewport(layout.pos.row = 2, layout.pos.col = 2))

# filter based on field samples
# filter based on qd > 20, sor < 1, mqrank > -2 

v_ids <- (gatk_df %>% filter(qd > 15, mq > 50, sor < 1,
                             mqrank > -2 | is.na(mqrank)))$variant.id
```

We see that all variants are supported by high residual mean square mapping
qualities over all samples. The distribution of MQRankSum scores (which is only
computed at heterozygous sites) is centred at 0 with a fat right tail. For this
tag only negative scores are useful since that indicates that the mapping quality
for the alternate allele is low compared to the reference allele. The QD distribution
is relatively symmetric and centred at around 20, most variants have relatively
good ratios of  average quality to average depth. The SOR tag is an odds
ratio score to detect strand bias from a 2 x 2 contingency table using the strands
and alt/ref allele counts as the rows and columns respectively.

We apply some hard filters to all samples,
* QD score > 15
* SOR < 1
* MQRankSum > -2 (allowed to be missing for sites with heterozygous calls)
* MQ > 50

This leaves approximately `r length(v_ids)` SNVs. 

Of the remaining SNVs we then split the data by country and 
apply the following filters

1. Extract SNVs that are covered to at least 5 bases in 90% of samples.
2. Extract SNVs that are polymorphic in the country of interest.
3. Find samples that have 90% of their SNVs covered to at least 5 bases
4. Take intersect set of SNVs that meet criteria 1 and 2 within each country 
across a region. Include samples that meet that criteria within a region. 
5. Using the intersect set of SNVs and compute MAF distributions within each 
country. 
6. Apply a MAF filter of 1% within each country
7. Take intersect set of SNPs that meet 6.) within each country accross a region.

To do this we construct a nested list data structure of where that consist
of three lists per region and lists containing the following for each country:
  
  * sample identifiers meeting our criteria
  * SNP identifiers meeting our criteria
  * Fws estimates
  * MAF estimates

We also plot the ECDFs for all these parameters.

```{r snp-distributions, cache=TRUE}
mgen_stats <- list()

for (location in unique(field_isolates$region)) {
  mgen_stats[[location]] <- list()
  country_unique <- unique(field_isolates$country[field_isolates$region == location])
  for (country in country_unique) {
    mgen_stats[[location]][[country]] <- list()
    # apply filter first pass
    samples <- field_isolates$sample[field_isolates$country == country]
    # filter first
    seqSetFilter(mgen, sample.id = samples, variant.id = v_ids)
    # SNVs covered to 5 bases overall samples in country
    # first pass at computing MAF
    maf_init <- getMAF(mgen)
    # exclude variants that have MAF <= 0 and snp_5x < 0.9
    variants_step1 <- v_ids[maf_init > 0]
    seqSetFilter(mgen, variant.id = variants_step1)
    
    snp_5x <- perSiteCoverageBySample(mgen, 5L)
    variants_step2 <- variants_step1[snp_5x > 0.9]
    seqSetFilter(mgen, variant.id = variants_step2)
    
    # sample exclusions
    sample_5x <- perSiteCoverageBySNP(mgen, 5L)
    # samples to keep
    samples_step1 <- samples[sample_5x >= 0.9]
    
    seqSetFilter(mgen, sample.id = samples_step1, variant.id = variants_step2)
    # maf final
    maf_final <- getMAF(mgen)
    variants_step3 <- seqGetData(mgen, "variant.id")
    # estimate Fws on subset region
    # fws_final 
    fws_final <- getFws(mgen)
    
    maf_filter <- variants_step3[maf_final > 0.01] 
    # collect data 
    mgen_stats[[location]][[country]]$samples <- samples_step1
    mgen_stats[[location]][[country]]$snps <- maf_filter
    mgen_stats[[location]][[country]]$fws <- fws_final
    # create plots
    par(mfrow = c(2,2))
    
    plot(ecdf(snp_5x),
     xlab = "Proportion of SNPs", 
     ylab = "Cumulative proportion of of samples",
     main = paste("ECDF coverage at 5x for", country))
    
    plot(ecdf(sample_5x),
     xlab = "Proportion of samples",
     ylab = "Cumulative proportion of SNPs",
     main= paste("ECDF coverage at 5x for", country))
    
    plot(ecdf(maf_final),
         xlab =  "MAF",
         main = paste("MAF distribution", country))
    
    plot(ecdf(fws_final),
         xlab = "Fws",
         main = paste("Fws distribution for", country))
    dev.off()
    # reset filter
    seqSetFilter(mgen)
  }
}

```

The following table presents the counts of SNPs and samples for each regions,
that fit the above filters.

```{r snps-summary}
filter_results <- lapply(mgen_stats, 
                         function(country_list)  { 
                           data.frame(country = names(country_list),
                                      bind_rows(lapply(country_list, 
                                                       function(info) {
                                                         data.frame(n_snps = length(info$snps),
                                                                    n_samples = length(info$samples))
                                                       })))})
knitr::kable(left_join(field_isolates %>% 
                         distinct(region, country)  %>% 
                         select(region, country),
                       bind_rows(filter_results)))
```

Aside from Nigerian samples we appear to have obtained enough SNPs within each
region for local IBD analysis. Futhermore, we appear to have gotten similar SNP
counts per region which is reassuring. We will exclude those samples in Nigeria
from downstream analysis. If we take the unique number of SNPs at MAF > 1\% per
country within a region we get the following SNP counts by region:

```{r region-snp-summary}

region_results <- lapply(mgen_stats, 
                         function(country_list)
                           lapply(country_list, function(info) info$snps))

# remove Nigieria as sample size is very low
wa_countries <- names(region_results[[1]])  
region_results[[1]] <- region_results[[1]][wa_countries != "Nigeria"]

by_region_snps <- lapply(region_results, 
                         function(region) Reduce("unique", region))

knitr::kable(unlist(lapply(by_region_snps, length)) %>% data.frame)
# extract samples 
region_results_samples <- lapply(mgen_stats,
                            function(country_list) lapply(country_list, 
                                                          function(info) info$samples))
region_results_samples[[1]] <- region_results_samples[[1]][wa_countries != "Nigeria"]

by_region_samples <- lapply(region_results_samples, 
                            function(region) unlist(region, use.names = FALSE))

```


# Constructing three region specific data subsets

For the IBD analysis we require filters on the variants to ensure the SNPs
have high enough MAFs and to annotate samples that are putatively clonal. 

To do this we perform the following steps
1. Subset the calls by geographic region defined above.
2. Use the $F_{ws}$ metric estimated above to annotate samples as either single clones 
or multiple clone infections. We use this for a quick proxy for multiple infections,
before assessing this in more detail using `moimix`.
3. Estimate the MAFs directly from read-count data within a region. We can then 
look at the overall estimated MAF distributions using our combined variant sets.

We also save the PED and MAP file, annotations,  as an R objects to speed up write-out.


```{r combined-maf}
# extract Fws metric 
by_region_fws <- lapply(mgen_stats, function(country_list) data.frame(fws = unlist(lapply(country_list, 
                                                                  function(info) info$fws))))
by_region_fws <- lapply(by_region_fws, function(x)  add_rownames(x, var = "id") %>% 
                          tidyr::separate(id, c("country", "sample.id"), "(\\.)(.*?)", extra = "merge"))
# filter out Nigeria
by_region_fws[[1]] <- filter(by_region_fws[[1]], country != "Nigeria")

# save mafs, annotations, Fws values in  list of data.frames
# extract PED and map files as well
for (region in unique(field_isolates$region)) {
  # subset 
  seqSetFilter(mgen, 
               sample.id = by_region_samples[[region]], 
               variant.id = by_region_snps[[region]])
  maf_by_region <- getMAF(mgen)
  
  cat(paste("##", region))

  hist(maf_by_region, breaks = 100,
       xlab = "MAF",
       main = paste("MAF distribution", region))
  
  # extract annotations for the subset
  annotations <- data.frame(chr = seqGetData(mgen, "chromosome"),
                          pos = seqGetData(mgen, "position"),
                          gene_name = seqGetData(mgen, "annotation/info/SNPEFF_GENE_NAME"),
                          gene_biotype = seqGetData(mgen, "annotation/info/SNPEFF_GENE_BIOTYPE"),
                          snp_effect = seqGetData(mgen, "annotation/info/SNPEFF_AMINO_ACID_CHANGE"),
                          snp_functional_class = seqGetData(mgen, "annotation/info/SNPEFF_EFFECT"), 
                          snp_aa_change = seqGetData(mgen, "annotation/info/SNPEFF_AMINO_ACID_CHANGE"),
                          snp_codon_change = seqGetData(mgen, "annotation/info/SNPEFF_CODON_CHANGE"),
                          exon_id = seqGetData(mgen, "annotation/info/SNPEFF_EXON_ID"),
                          transcript_id = seqGetData(mgen, "annotation/info/SNPEFF_TRANSCRIPT_ID"))
  
  # show annotation sets by chromosome
  
  knitr::kable(annotations %>% 
                 count(chr, snp_functional_class, gene_biotype))
  
  fws <- by_region_fws[[region]]
  # region summary
  region_summary <- list(maf = maf_by_region, annotations = annotations, fws = fws)
  write_rds(region_summary, 
            paste0("processed_data/", 
                   gsub(" ", "_", tolower(region)), "_summary.rds"))

  # extract PED
  region_plink <- extractPED(mgen, moi.estimates = ifelse(fws$fws > 0.95, 1, 2))
  write_rds(region_plink, 
            paste0("processed_data/", 
                   gsub(" ", "_", tolower(region)), "_ped.rds"))
  # extract genotypes
  region_genotypes <- alleleCounts(mgen)
  write_rds(region_genotypes, 
            paste0("processed_data/", 
                   gsub(" ", "_", tolower(region)), "_acounts.rds"))
  
}

```

 
# Appendix

```{r sessionInfo}
# tidy up gds
seqSetFilter(mgen)
seqClose(mgen)
# cleanup.gds("processed_data/malaria_gen5.gds")

sessionInfo()
```
